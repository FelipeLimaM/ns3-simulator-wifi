/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */

#include "ns3/core-module.h"
#include "ns3/propagation-module.h"
#include "ns3/network-module.h"
#include "ns3/applications-module.h"
#include "ns3/mobility-module.h"
#include "ns3/internet-module.h"
#include "ns3/flow-monitor-module.h"
#include "ns3/wifi-module.h"
#include <iostream>
#include <math.h>

using namespace ns3;
using namespace std;

//running settings
uint32_t nNodes = 5; //GLOBAL
static bool printLog = true;
bool runFull = false;
bool enableCtsRts = false;
double runningTime = 60.0;
double offTime = 0.001;
double onTime = 0.001;

void CourseChange (std::string context, Ptr<const MobilityModel> model){
  Vector position = model->GetPosition ();
  NS_LOG_UNCOND (context <<" x = " << position.x << ", y = " << position.y << " , z = " << position.z);
}

double calcDistance (int x1, int y1, int x2, int y2){
  return sqrt( pow (x2 - x1, 2) + pow (y2 - y1, 2));
}

int myRand(){
  //TODO DIOGOOOO Faz isso
  return rand();
}

void setMobility(bool bmobility, NodeContainer &apnode, NodeContainer &nodes) {

  MobilityHelper mobility;
  if(bmobility){
    //List of points
    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();
    for (size_t i = 0; i < nNodes; i++) {
      positionAlloc->Add (Vector (myRand()%100, myRand()%100, 0.0));
    }
    //Set list of points
    mobility.SetPositionAllocator (positionAlloc);
    //Set apnode static
    mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
    mobility.Install (apnode);
    //Set nodes with mobility
    Rectangle area = Rectangle (-5000, 5000, -5000, 5000); //Area of mobility
    mobility.SetMobilityModel ("ns3::RandomWalk2dMobilityModel","Bounds", RectangleValue (area));
    mobility.Install (nodes);
  }else{
    //Set local to nodes and apnode
    mobility.SetPositionAllocator ("ns3::GridPositionAllocator",
                                   "MinX", DoubleValue (0.0),
                                   "MinY", DoubleValue (0.0),
                                   "DeltaX", DoubleValue (20.0),
                                   "DeltaY", DoubleValue (20.0),
                                   "GridWidth", UintegerValue (5),
                                   "LayoutType", StringValue ("RowFirst"));
    mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
    mobility.Install (apnode);
    mobility.Install (nodes);
  }
}

void installWirelessDevice(NodeContainer &apnode, NodeContainer &nodes, NetDeviceContainer &apdevice, NetDeviceContainer &devices){

  // 5. Install wireless devices
  WifiHelper wifi;
  wifi.SetStandard (WIFI_PHY_STANDARD_80211b);
  wifi.SetRemoteStationManager ("ns3::ArfWifiManager");

  YansWifiChannelHelper wifiChannel;
  wifiChannel = YansWifiChannelHelper::Default ();

  YansWifiPhyHelper wifiPhy =  YansWifiPhyHelper::Default ();
  wifiPhy.SetChannel (wifiChannel.Create ());

  Ssid ssid = Ssid ("wifi-default");

  WifiMacHelper wifiMac;
  wifiMac.SetType ("ns3::StaWifiMac","Ssid", SsidValue (ssid));
  devices = wifi.Install (wifiPhy, wifiMac, nodes);
  // setup ap.
  wifiMac.SetType ("ns3::ApWifiMac","Ssid", SsidValue (ssid));
  apdevice = wifi.Install (wifiPhy, wifiMac, apnode);
}

void installInternetProtocol(NodeContainer &apnode, NodeContainer &nodes, NetDeviceContainer &apdevice, NetDeviceContainer &devices, Ipv4InterfaceContainer &apdeviceIP, Ipv4InterfaceContainer &devicesIP){

  // 6. Install TCP/IP stack & assign IP addresses
  InternetStackHelper internet;
  internet.Install (nodes);
  internet.Install (apnode);

  Ipv4AddressHelper ipv4;
  ipv4.SetBase ("198.162.10.0", "255.255.255.0");
  apdeviceIP = ipv4.Assign (apdevice);
  devicesIP = ipv4.Assign (devices);
}

void installUDPCommunication(NodeContainer &nodes, Ipv4InterfaceContainer &devicesIP){
  ApplicationContainer cbrApps;
  uint32_t id_server = myRand() % nNodes;

  //onTime and OffTime settings
  std::ostringstream ossOnTime;
  ossOnTime << "ns3::ConstantRandomVariable[Constant=" << onTime << "]";
  std::ostringstream ossOffTime;
  ossOffTime << "ns3::ConstantRandomVariable[Constant=" << offTime << "]";

  for (uint32_t i = 0; i < nNodes; i++){
    OnOffHelper onOffHelper ("ns3::UdpSocketFactory", InetSocketAddress (devicesIP.GetAddress(id_server), i+1000));
    onOffHelper.SetAttribute ("PacketSize", UintegerValue (484));
    onOffHelper.SetAttribute ("OnTime",StringValue(ossOnTime.str()));
    onOffHelper.SetAttribute ("OffTime",StringValue(ossOffTime.str()));

    onOffHelper.SetAttribute ("DataRate", StringValue ("512kbps"));
    onOffHelper.SetAttribute ("StartTime", TimeValue (Seconds (1.001)));
    cbrApps.Add (onOffHelper.Install (nodes.Get(i)));
  }

  // Start and stop time of application
  cbrApps.Start(Seconds(1.0));
  cbrApps.Stop(Seconds(runningTime+1));
}

void installTCPCommunication(NodeContainer &apnode, NodeContainer &nodes, NetDeviceContainer &apdevice, NetDeviceContainer &devices, Ipv4InterfaceContainer &apdeviceIP, Ipv4InterfaceContainer &devicesIP){
  //TODO
  /* Install TCP Receiver on the access point */
  PacketSinkHelper sinkHelper ("ns3::TcpSocketFactory", InetSocketAddress (Ipv4Address::GetAny (), 9));
  ApplicationContainer sinkApp = sinkHelper.Install (nodes);

  /* Install TCP/UDP Transmitter on the station */
  OnOffHelper server ("ns3::TcpSocketFactory", (InetSocketAddress (devicesIP.GetAddress(0), 9)));
  server.SetAttribute ("PacketSize", UintegerValue (484));
  server.SetAttribute ("OnTime", StringValue ("ns3::ConstantRandomVariable[Constant=1]"));
  server.SetAttribute ("OffTime", StringValue ("ns3::ConstantRandomVariable[Constant=0]"));
  server.SetAttribute ("DataRate", StringValue ("512kbps"));
  ApplicationContainer serverApp = server.Install (nodes.Get(4));
}

void buildStatistics(FlowMonitorHelper &flowmon, Ptr<FlowMonitor> &monitor){

  double throughput = 0;
  double delay = 0;
  double meanThroughput = 0.0;
  double meanDelayPackets = 0.0;
  double meanLostPackets = 0.0;
  int count = 0;

  monitor->CheckForLostPackets();
  FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats ();

  for (map<FlowId, FlowMonitor::FlowStats>::const_iterator i=stats.begin (); i != stats.end (); ++i, count++){

    throughput = (i->second.rxBytes) / ((i->second.timeLastRxPacket - i->second.timeFirstRxPacket).GetSeconds());

    cout << "Flowid              = " << i->first << endl;
    cout << "First Tx Packet     = " << i->second.timeFirstTxPacket.GetSeconds() << endl;
    cout << "First Rx Packet     = " << i->second.timeFirstRxPacket.GetSeconds() << endl;
    cout << "Last Tx Packet      = " << i->second.timeLastTxPacket.GetSeconds() << endl;
    cout << "Last Rx Packet      = " << i->second.timeLastRxPacket.GetSeconds() << endl;
    cout << "Tx Packets          = " << i->second.txPackets << endl;
    cout << "RX Packets          = " << i->second.rxPackets << endl;
    cout << "Lost Packets        = " << i->second.lostPackets << endl;
    cout << "Tx Bytes            = " << i->second.txBytes << endl;
    cout << "RX bytes            = " << i->second.rxBytes << endl;
    cout << "Delay Sum           = " << i->second.delaySum.GetSeconds() << endl;
    cout << "Delay/Packet (mean) = " << i->second.delaySum.GetSeconds()/i->second.rxPackets << endl;
    cout << "Received Throughput = " << throughput << " bps" << " " << throughput/1000 << " kbps" << endl << endl;

    meanThroughput += ((throughput > 0) ? throughput : 0);
    delay = i->second.delaySum.GetSeconds()/i->second.rxPackets;
    meanDelayPackets += ((delay > 0) ? delay : 0);
    meanLostPackets += i->second.lostPackets;
  }

  meanThroughput /= count;
  meanDelayPackets /= count;
  meanLostPackets /= count;

  cout << "Throughput (mean)   : " << meanThroughput/1000 << " kbps"<< endl;
  cout << "Delay Packets (mean): " << meanDelayPackets << endl;
  cout << "Lost Packets (mean) : " << meanLostPackets << endl;
}

void run (){

  // 0. Enable or disable CTS/RTS
  // Hidden station experiment with RTS/CTS disabled, if enableCtsRts is FALSE
  UintegerValue ctsThr = (enableCtsRts ? UintegerValue (100) : UintegerValue (2200));
  Config::SetDefault ("ns3::WifiRemoteStationManager::RtsCtsThreshold", ctsThr);

  NodeContainer apnode, nodes;
  NetDeviceContainer apdevice, devices;
  Ipv4InterfaceContainer apdeviceIP, devicesIP;

  //Create nodes
  apnode.Create (1);
  nodes.Create (nNodes);

  // if value TRUE, exist mobility, else, not exist mobility.
  setMobility(false, apnode, nodes);

  installWirelessDevice(apnode, nodes, apdevice, devices);

  installInternetProtocol(apnode, nodes, apdevice, devices, apdeviceIP, devicesIP);

  /* Populate routing table */
  Ipv4GlobalRoutingHelper::PopulateRoutingTables ();


  // installUDPCommunication(nodes, devicesIP);

  installTCPCommunication(apnode, nodes, apdevice, devices, apdeviceIP, devicesIP);


  // Install FlowMonitor on all nodes
  FlowMonitorHelper flowmon;
  Ptr<FlowMonitor> monitor = flowmon.InstallAll ();

  // /NodeList/9/$ns3::MobilityModel/
  // Config::Connect ("/NodeList/*/$ns3::MobilityModel/CourseChange", MakeCallback (&CourseChange));

  // Simulation running time
  Simulator::Stop (Seconds (runningTime+2));
  Simulator::Run ();

  // execute magic of the flowmon
  monitor->SerializeToXmlFile("wifiinfra.xml", true, true);
  if(printLog)
    buildStatistics(flowmon, monitor);

  // Cleanup
  Simulator::Destroy ();
}

int main (int argc, char **argv){

  CommandLine cmd;

  cmd.AddValue("nodes", "Number of sta nodes", nNodes);
  cmd.AddValue("runningTime", "Application running time in seconds", runningTime);
  cmd.AddValue("onTime", "OnOff app time running on", onTime);
  cmd.AddValue("offTime", "OnOff app time running off", offTime);
  cmd.AddValue("printLog", "Print Statistics? (true/false)", printLog);
  cmd.AddValue("runFull", "Run full simutation? (true/false)", runFull);

  cmd.Parse (argc, argv);

  run ();

  return 0;
}
