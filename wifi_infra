/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */

#include "ns3/core-module.h"
#include "ns3/propagation-module.h"
#include "ns3/network-module.h"
#include "ns3/applications-module.h"
#include "ns3/mobility-module.h"
#include "ns3/internet-module.h"
#include "ns3/flow-monitor-module.h"
#include "ns3/wifi-module.h"
#include <iostream>
#include <math.h>

using namespace ns3;
using namespace std;

//running settings
uint32_t nNodes = 5; //GLOBAL
static bool printLog = true;
bool enableCtsRts = false;
bool traffic = true;
bool mobility = false;
uint32_t packetsize;
double runningTime = 60.0;
double offTime = 0.001;
double onTime = 0.001;

size_t nearNode = -1;
size_t farNode = -1;
double dNearNode;
double dFarNode;


void CourseChange (std::string context, Ptr<const MobilityModel> model){
  Vector position = model->GetPosition ();
  NS_LOG_UNCOND (context <<" x = " << position.x << ", y = " << position.y << " , z = " << position.z);
}

double calcDistance (uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2){
  return sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
}

void findNode(uint32_t ApX, uint32_t ApY, uint32_t NodeX, uint32_t NodeY, size_t id){
  double result = calcDistance(ApX, ApY, NodeX, NodeY);
  std::cout<< "ID: " << id << " - " << result << "\n (" <<  NodeX <<","<< NodeY << ")" << std::endl;
  if(id == 0){
    nearNode = id;
    farNode = id;
    dNearNode = result;
    dFarNode = result;
  }else{
    if(result > dFarNode){
      farNode = id;
      dFarNode = result;
    }
    if(result < dNearNode){
      nearNode = id;
      dNearNode = result;
    }
  }
}

int myRand(int min, int max){

  Ptr<UniformRandomVariable> x = CreateObject<UniformRandomVariable> ();
  x->SetAttribute ("Min", DoubleValue (min));
  x->SetAttribute ("Max", DoubleValue (max));

  int value = x->GetValue ();

  return value;
}

void setMobility(NodeContainer &apnode, NodeContainer &nodes) {

  MobilityHelper mobilityh;
  //List of points
  Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();
  //Set apnode static
  uint32_t ApX = myRand(0, 100);
  uint32_t ApY = myRand(0, 100);
  positionAlloc->Add (Vector (ApX, ApY, 0.0));
  mobilityh.SetPositionAllocator (positionAlloc);
  mobilityh.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
  mobilityh.Install (apnode);
  //Set station node static
  if(mobility){
    //Set nodes with mobility
    Rectangle area = Rectangle (-5000, 5000, -5000, 5000); //Area of mobility
    mobilityh.SetMobilityModel ("ns3::RandomWalk2dMobilityModel","Bounds", RectangleValue (area));
  }
  for (size_t i = 0; i < nNodes; i++) {
    uint32_t NodeX = myRand(0, 100);
    uint32_t NodeY = myRand(0, 100);
    findNode(ApX, ApY, NodeX, NodeY, i);
    positionAlloc = CreateObject<ListPositionAllocator> ();
    positionAlloc->Add (Vector (NodeX, NodeY, 0.0));
    mobilityh.SetPositionAllocator (positionAlloc);
    mobilityh.Install (nodes.Get(i));
  }
  std::cout << "Mais Distante: " << farNode << "     com a distancia de " << dFarNode << "." << std::endl;
  std::cout << "Mais Proximo : " << nearNode << "    com a distancia de " << dNearNode << "." << std::endl;
  //Set list of points

}

void installWirelessDevice(NodeContainer &apnode, NodeContainer &nodes, NetDeviceContainer &apdevice, NetDeviceContainer &devices){

  // 5. Install wireless devices
  WifiHelper wifi;
  wifi.SetStandard (WIFI_PHY_STANDARD_80211b);
  wifi.SetRemoteStationManager ("ns3::ArfWifiManager");

  YansWifiChannelHelper wifiChannel;
  wifiChannel = YansWifiChannelHelper::Default ();

  YansWifiPhyHelper wifiPhy =  YansWifiPhyHelper::Default ();
  wifiPhy.SetChannel (wifiChannel.Create ());

  Ssid ssid = Ssid ("wifi-default");

  WifiMacHelper wifiMac;
  wifiMac.SetType ("ns3::StaWifiMac","Ssid", SsidValue (ssid));
  devices = wifi.Install (wifiPhy, wifiMac, nodes);
  // setup ap.
  wifiMac.SetType ("ns3::ApWifiMac","Ssid", SsidValue (ssid));
  apdevice = wifi.Install (wifiPhy, wifiMac, apnode);
}

void installInternetProtocol(NodeContainer &apnode, NodeContainer &nodes, NetDeviceContainer &apdevice, NetDeviceContainer &devices, Ipv4InterfaceContainer &apdeviceIP, Ipv4InterfaceContainer &devicesIP){

  // 6. Install TCP/IP stack & assign IP addresses
  InternetStackHelper internet;
  internet.Install (nodes);
  internet.Install (apnode);

  Ipv4AddressHelper ipv4;
  ipv4.SetBase ("198.162.10.0", "255.255.255.0");
  apdeviceIP = ipv4.Assign (apdevice);
  devicesIP = ipv4.Assign (devices);

  for (size_t i = 0; i < nNodes; i++) {
    std::cout << i << " - " << devicesIP.GetAddress(i) << '\n';
  }
}

void installUDPCommunication(NodeContainer &nodes, Ipv4InterfaceContainer &devicesIP){
  ApplicationContainer cbrApps;
  uint32_t id_server = myRand(0, nNodes);

  //onTime and OffTime settings
  std::ostringstream ossOnTime;
  ossOnTime << "ns3::ConstantRandomVariable[Constant=" << onTime << "]";
  std::ostringstream ossOffTime;
  ossOffTime << "ns3::ConstantRandomVariable[Constant=" << offTime << "]";

  for (uint32_t i = 0; i < nNodes; i++){
    OnOffHelper onOffHelper ("ns3::UdpSocketFactory", InetSocketAddress (devicesIP.GetAddress(id_server), i+1000));
    onOffHelper.SetAttribute ("PacketSize", UintegerValue (packetsize));
    onOffHelper.SetAttribute ("OnTime",StringValue(ossOnTime.str()));
    onOffHelper.SetAttribute ("OffTime",StringValue(ossOffTime.str()));

    onOffHelper.SetAttribute ("DataRate", StringValue ("512kbps"));
    onOffHelper.SetAttribute ("StartTime", TimeValue (Seconds (1.001)));
    cbrApps.Add (onOffHelper.Install (nodes.Get(i)));
  }

  // Start and stop time of application
  cbrApps.Start(Seconds(1.0));
  cbrApps.Stop(Seconds(runningTime+1));
}

void installTCPCommunication(NodeContainer &apnode, NodeContainer &nodes, NetDeviceContainer &apdevice, NetDeviceContainer &devices, Ipv4InterfaceContainer &apdeviceIP, Ipv4InterfaceContainer &devicesIP){
  //TODO

  // uint32_t id_server = myRand(0, nNodes);

  ApplicationContainer serverApp;
  ApplicationContainer sinkApp;

  std::ostringstream ossOnTime;
  ossOnTime << "ns3::ConstantRandomVariable[Constant=" << onTime << "]";
  std::ostringstream ossOffTime;
  ossOffTime << "ns3::ConstantRandomVariable[Constant=" << offTime << "]";

  /* Install TCP/UDP Transmitter on the station */
  for (uint32_t i = 0; i < nNodes; i++){
  /* Install TCP Receiver on the access point */
    PacketSinkHelper sinkHelper ("ns3::TcpSocketFactory", InetSocketAddress (Ipv4Address::GetAny(), i+10000));
    sinkApp.Add (sinkHelper.Install (nodes));
    OnOffHelper server ("ns3::TcpSocketFactory", (InetSocketAddress (devicesIP.GetAddress(i), i+10000)));
    server.SetAttribute ("PacketSize", UintegerValue (1484));
    server.SetAttribute ("OnTime", StringValue(ossOnTime.str()));
    server.SetAttribute ("OffTime", StringValue(ossOffTime.str()));
    server.SetAttribute ("DataRate", StringValue ("512kbps"));
    serverApp.Add(server.Install (nodes.Get(myRand(0,nNodes))));
  }


    sinkApp.Start (Seconds (0.0));
    serverApp.Start (Seconds (1.0));
    serverApp.Stop(Seconds(runningTime+1));
}

void buildStatistics(FlowMonitorHelper &flowmon, Ptr<FlowMonitor> &monitor){

  double throughput = 0;
  double delay = 0;
  double meanThroughput = 0.0;
  double meanDelayPackets = 0.0;
  double meanLostPackets = 0.0;
  int count = 0;

  monitor->CheckForLostPackets();
  FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats ();

  Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowmon.GetClassifier ());

  for (map<FlowId, FlowMonitor::FlowStats>::const_iterator i=stats.begin (); i != stats.end (); ++i, count++){

    throughput = (i->second.rxBytes * 8) / ((i->second.timeLastRxPacket - i->second.timeFirstRxPacket).GetSeconds());
    Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (i->first);

    if(printLog){
      cout << "Flowid              = " << i->first << endl;
      cout << "Source Address      = " << t.sourceAddress << endl;
      cout << "Destination Address = " << t.destinationAddress << endl;
      cout << "First Tx Packet     = " << i->second.timeFirstTxPacket.GetSeconds() << endl;
      cout << "First Rx Packet     = " << i->second.timeFirstRxPacket.GetSeconds() << endl;
      cout << "Last Tx Packet      = " << i->second.timeLastTxPacket.GetSeconds() << endl;
      cout << "Last Rx Packet      = " << i->second.timeLastRxPacket.GetSeconds() << endl;
      cout << "Tx Packets          = " << i->second.txPackets << endl;
      cout << "RX Packets          = " << i->second.rxPackets << endl;
      cout << "Lost Packets        = " << i->second.lostPackets << endl;
      cout << "Tx Bytes            = " << i->second.txBytes << endl;
      cout << "RX bytes            = " << i->second.rxBytes << endl;
      cout << "Delay Sum           = " << i->second.delaySum.GetSeconds() << endl;
      cout << "Delay/Packet (mean) = " << i->second.delaySum.GetSeconds()/i->second.rxPackets << endl;
      cout << "Received Throughput = " << throughput << " bps" << " " << throughput/1000 << " kbps" << endl << endl;
    }

    meanThroughput += ((throughput > 0) ? throughput : 0);
    delay = i->second.delaySum.GetSeconds()/i->second.rxPackets;
    meanDelayPackets += ((delay > 0) ? delay : 0);
    meanLostPackets += i->second.lostPackets;
  }

  meanThroughput /= count;
  meanDelayPackets /= count;
  meanLostPackets /= count;

  cout << "Throughput (mean)   : " << meanThroughput/1000 << " kbps"<< endl;
  cout << "Delay Packets (mean): " << meanDelayPackets << endl;
  cout << "Lost Packets (mean) : " << meanLostPackets << endl;

  FILE *f;
  // if udp/cbr
  if(traffic){
    if(mobility){
      f = fopen("RandomWalk_cbr.csv", "a");
      fprintf(f, "%d;%.2f;%.2f;%.2f\n", nNodes, meanThroughput/1000, meanDelayPackets, meanLostPackets);
    }
    else{
      f = fopen("ConstantPosition_cbr.csv", "a");
      fprintf(f, "%d;%.2f;%.2f;%.2f\n", nNodes, meanThroughput/1000, meanDelayPackets, meanLostPackets);
    }
  }
  else{
    if(mobility){
      f = fopen("RandomWalk_pulse.csv", "a");
      fprintf(f, "%d;%.2f;%.2f;%.2f\n", nNodes, meanThroughput/1000, meanDelayPackets, meanLostPackets);
    }
    else{
      f = fopen("ConstantPosition_pulse_cbr.csv", "a");
      fprintf(f, "%d;%.2f;%.2f;%.2f\n", nNodes, meanThroughput/1000, meanDelayPackets, meanLostPackets);
    }
  }
  fclose(f);
}

void run (){

  // 0. Enable or disable CTS/RTS
  // Hidden station experiment with RTS/CTS disabled, if enableCtsRts is FALSE
  UintegerValue ctsThr = (enableCtsRts ? UintegerValue (100) : UintegerValue (2200));
  Config::SetDefault ("ns3::WifiRemoteStationManager::RtsCtsThreshold", ctsThr);

  NodeContainer apnode, nodes;
  NetDeviceContainer apdevice, devices;
  Ipv4InterfaceContainer apdeviceIP, devicesIP;

  //Create nodes
  apnode.Create (1);
  nodes.Create (nNodes);

  // if value TRUE, exist mobility, else, not exist mobility.
  setMobility(apnode, nodes);

  installWirelessDevice(apnode, nodes, apdevice, devices);

  installInternetProtocol(apnode, nodes, apdevice, devices, apdeviceIP, devicesIP);

  /* Populate routing table */
  Ipv4GlobalRoutingHelper::PopulateRoutingTables ();

  // if udp/cbr
  if(traffic)
    installUDPCommunication(nodes, devicesIP);
  else
    installTCPCommunication(apnode, nodes, apdevice, devices, apdeviceIP, devicesIP);

  // Install FlowMonitor on all nodes
  FlowMonitorHelper flowmon;
  Ptr<FlowMonitor> monitor = flowmon.InstallAll ();

  // /NodeList/9/$ns3::MobilityModel/
  // Config::Connect ("/NodeList/*/$ns3::MobilityModel/CourseChange", MakeCallback (&CourseChange));

  // Simulation running time
  Simulator::Stop (Seconds (runningTime+2));
  Simulator::Run ();

  // execute magic of the flowmon
  monitor->SerializeToXmlFile("wifiinfra.xml", true, true);
  buildStatistics(flowmon, monitor);

  // Cleanup
  Simulator::Destroy ();
}

int main (int argc, char **argv){

  CommandLine cmd;

  cmd.AddValue("nodes", "Number of sta nodes", nNodes);
  cmd.AddValue("runningTime", "Application running time in seconds", runningTime);
  cmd.AddValue("traffic", "Traffic (CBR=true, pulse=false)", traffic);
  cmd.AddValue("mobility", "Mobile nodes (true/false)", mobility);
  cmd.AddValue("printLog", "Print Statistics? (true/false)", printLog);

  cmd.Parse (argc, argv);

  if(traffic){
    packetsize = 484;
    onTime = 0.001;
    offTime = 0.001;
  }
  else{
    packetsize = 1484;
    onTime = 2.0;
    offTime = 3.0;
  }

  run ();

  return 0;
}
